// This file was GENERATED by command:
//     pump.py callback_helper.h.pump
// DO NOT EDIT BY HAND!!!


// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef CHROME_BROWSER_SYNC_FILE_SYSTEM_DRIVE_BACKEND_CALLBACK_HELPER_H_
#define CHROME_BROWSER_SYNC_FILE_SYSTEM_DRIVE_BACKEND_CALLBACK_HELPER_H_

#include "base/bind.h"
#include "base/location.h"
#include "base/logging.h"
#include "base/thread_task_runner_handle.h"

// TODO(tzik): Merge this file to media/base/bind_to_current_loop.h.

namespace sync_file_system {
namespace drive_backend {

namespace internal {

template <typename T>
typename base::enable_if<
    base::internal::IsMoveOnlyType<T>::value,
    base::internal::PassedWrapper<T> >::type
RebindForward(T& t) {
  return base::Passed(&t);
}

template <typename T>
typename base::enable_if<
    !base::internal::IsMoveOnlyType<T>::value,
    T&>::type
RebindForward(T& t) {
  return t;
}

template <typename>
struct RelayToTaskRunnerHelper;

template <>
struct RelayToTaskRunnerHelper<void()> {
  static void Run(base::TaskRunner* task_runner,
                  const tracked_objects::Location& from_here,
                  const base::Callback<void()>& callback) {
    task_runner->PostTask(from_here, base::Bind(callback));
  }
};

template <typename A1>
struct RelayToTaskRunnerHelper<void(A1)> {
  static void Run(base::TaskRunner* task_runner,
                  const tracked_objects::Location& from_here,
                  const base::Callback<void(A1)>& callback, A1 a1) {
    task_runner->PostTask(from_here, base::Bind(callback, RebindForward(a1)));
  }
};

template <typename A1, typename A2>
struct RelayToTaskRunnerHelper<void(A1, A2)> {
  static void Run(base::TaskRunner* task_runner,
                  const tracked_objects::Location& from_here,
                  const base::Callback<void(A1, A2)>& callback, A1 a1, A2 a2) {
    task_runner->PostTask(from_here, base::Bind(callback, RebindForward(a1),
        RebindForward(a2)));
  }
};

template <typename A1, typename A2, typename A3>
struct RelayToTaskRunnerHelper<void(A1, A2, A3)> {
  static void Run(base::TaskRunner* task_runner,
                  const tracked_objects::Location& from_here,
                  const base::Callback<void(A1, A2, A3)>& callback, A1 a1,
                      A2 a2, A3 a3) {
    task_runner->PostTask(from_here, base::Bind(callback, RebindForward(a1),
        RebindForward(a2), RebindForward(a3)));
  }
};

template <typename A1, typename A2, typename A3, typename A4>
struct RelayToTaskRunnerHelper<void(A1, A2, A3, A4)> {
  static void Run(base::TaskRunner* task_runner,
                  const tracked_objects::Location& from_here,
                  const base::Callback<void(A1, A2, A3, A4)>& callback, A1 a1,
                      A2 a2, A3 a3, A4 a4) {
    task_runner->PostTask(from_here, base::Bind(callback, RebindForward(a1),
        RebindForward(a2), RebindForward(a3), RebindForward(a4)));
  }
};

template <typename A1, typename A2, typename A3, typename A4, typename A5>
struct RelayToTaskRunnerHelper<void(A1, A2, A3, A4, A5)> {
  static void Run(base::TaskRunner* task_runner,
                  const tracked_objects::Location& from_here,
                  const base::Callback<void(A1, A2, A3, A4, A5)>& callback,
                      A1 a1, A2 a2, A3 a3, A4 a4, A5 a5) {
    task_runner->PostTask(from_here, base::Bind(callback, RebindForward(a1),
        RebindForward(a2), RebindForward(a3), RebindForward(a4),
        RebindForward(a5)));
  }
};

template <typename A1, typename A2, typename A3, typename A4, typename A5,
    typename A6>
struct RelayToTaskRunnerHelper<void(A1, A2, A3, A4, A5, A6)> {
  static void Run(base::TaskRunner* task_runner,
                  const tracked_objects::Location& from_here,
                  const base::Callback<void(A1, A2, A3, A4, A5, A6)>& callback,
                      A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6) {
    task_runner->PostTask(from_here, base::Bind(callback, RebindForward(a1),
        RebindForward(a2), RebindForward(a3), RebindForward(a4),
        RebindForward(a5), RebindForward(a6)));
  }
};

template <typename A1, typename A2, typename A3, typename A4, typename A5,
    typename A6, typename A7>
struct RelayToTaskRunnerHelper<void(A1, A2, A3, A4, A5, A6, A7)> {
  static void Run(base::TaskRunner* task_runner,
                  const tracked_objects::Location& from_here,
                  const base::Callback<void(A1, A2, A3, A4, A5, A6,
                      A7)>& callback, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6,
                      A7 a7) {
    task_runner->PostTask(from_here, base::Bind(callback, RebindForward(a1),
        RebindForward(a2), RebindForward(a3), RebindForward(a4),
        RebindForward(a5), RebindForward(a6), RebindForward(a7)));
  }
};

}  // namespace internal

template <typename T>
base::Callback<T> RelayCallbackToTaskRunner(
    base::TaskRunner* task_runner,
    const tracked_objects::Location& from_here,
    const base::Callback<T>& callback) {
  DCHECK(task_runner->RunsTasksOnCurrentThread());

  if (callback.is_null())
    return base::Callback<T>();

  return base::Bind(&internal::RelayToTaskRunnerHelper<T>::Run,
                    make_scoped_refptr(task_runner), from_here,
                    callback);
}

template <typename T>
base::Callback<T> RelayCallbackToCurrentThread(
    const tracked_objects::Location& from_here,
    const base::Callback<T>& callback) {
  return RelayCallbackToTaskRunner(
      base::ThreadTaskRunnerHandle::Get(),
      from_here, callback);
}

}  // namespace drive_backend
}  // namespace sync_file_system

#endif  // CHROME_BROWSER_SYNC_FILE_SYSTEM_DRIVE_BACKEND_CALLBACK_HELPER_H_
